### ğŸ“˜ è¯æ±‡è¡¨ï¼ˆWordsï¼‰â€” arXiv:2601.14192

#### Nounsï¼ˆåè¯ï¼‰

| è‹±æ–‡ | ç¾å¼éŸ³æ ‡ | ä¸­æ–‡å«ä¹‰ | è¿‘ä¹‰è¯ | ç¤ºä¾‹ |
|------|----------|----------|--------|------|
| agent | /ËˆeÉªdÊ’É™nt/ | æ™ºèƒ½ä½“ï¼›ä»£ç† | actor; assistant | An efficient agent reduces tokens and latency across steps. |
| efficiency | /ÉªËˆfÉªÊƒÉ™nsi/ | æ•ˆç‡ | effectiveness-per-cost; efficiency gain | The survey emphasizes efficiency for real-world deployment. |
| latency | /ËˆleÉªtÉ™nsi/ | å»¶è¿Ÿ | response time; lag | Tool calls often increase end-to-end latency. |
| token | /ËˆtoÊŠkÉ™n/ | è¯å…ƒï¼›token | subword; unit | Token consumption compounds across multi-step trajectories. |
| saturation | /ËŒsÃ¦tÊƒÉ™ËˆreÉªÊƒÉ™n/ | é¥±å’Œï¼›ï¼ˆèµ„æº/çª—å£ï¼‰é¥±å’Œ | overload; crowding | Context window saturation can hurt long-horizon agents. |
| bottleneck | /ËˆbÉ‘ËtÌ¬lËŒnÉ›k/ | ç“¶é¢ˆ | constraint; choke point | Efficiency becomes a deployment bottleneck for agents. |
| deployment | /dÉªËˆplÉ”ÉªmÉ™nt/ | éƒ¨ç½² | rollout; release | Latency matters most at deployment time. |
| sustainability | /sÉ™ËŒsteÉªnÉ™ËˆbÉªlÉ™ti/ | å¯æŒç»­æ€§ | viability; endurance | High cost threatens the sustainability of agentic systems. |
| accessibility | /É™kËŒsÉ›sÉ™ËˆbÉªlÉ™ti/ | å¯è·å¾—æ€§ï¼›å¯åŠæ€§ | availability; reach | Lower cost improves equitable accessibility. |
| memory | /ËˆmÉ›mÉ™ri/ | è®°å¿†æ¨¡å—ï¼›å­˜å‚¨ | storage; recall | Memory helps agents avoid redundant computation. |
| context | /ËˆkÉ‘ËntÉ›kst/ | ä¸Šä¸‹æ–‡ | prompt; surrounding text | Long context may bury relevant evidence. |
| window | /ËˆwÉªndoÊŠ/ | ï¼ˆä¸Šä¸‹æ–‡ï¼‰çª—å£ | span; limit | The context window is finite. |
| overhead | /ËˆoÊŠvÉ™rËŒhÉ›d/ | é¢å¤–å¼€é”€ | extra cost; burden | Retrieval introduces system overhead and latency. |
| trajectory | /trÉ™ËˆdÊ’É›ktÉ™ri/ | ï¼ˆäº¤äº’ï¼‰è½¨è¿¹ï¼›å¤šæ­¥è¿‡ç¨‹ | rollout; sequence | The agentâ€™s trajectory may include retries and tool calls. |
| retrieval | /rÉªËˆtriËvÉ™l/ | æ£€ç´¢ | lookup; fetch | Retrieval quality affects both cost and accuracy. |
| compression | /kÉ™mËˆprÉ›ÊƒÉ™n/ | å‹ç¼© | shortening; condensing | Compression bounds token growth under a budget. |
| summarization | /ËŒsÊŒmÉ™rÉ™ËˆzeÉªÊƒÉ™n/ | æ‘˜è¦åŒ–ï¼›æ€»ç»“ | abstraction; synopsis | Summarization turns long histories into manageable memory. |
| taxonomy | /tÃ¦kËˆsÉ‘ËnÉ™mi/ | åˆ†ç±»ä½“ç³» | categorization; framework | The paper proposes a taxonomy of efficiency methods. |
| benchmark | /ËˆbÉ›ntÊƒËŒmÉ‘Ërk/ | åŸºå‡†ï¼›è¯„æµ‹ | evaluation set; yardstick | Benchmarks report both effectiveness and efficiency metrics. |
| protocol | /ËˆproÊŠtÌ¬É™ËŒkÉ”Ël/ | åè®®ï¼›æµç¨‹è§„èŒƒ | procedure; standard | MCP-style protocols standardize tool definitions and calls. |
| metric | /ËˆmÉ›trÉªk/ | æŒ‡æ ‡ | measure; indicator | Token usage is a common efficiency metric. |
| frontier | /frÊŒnËˆtÉªr/ | å‰æ²¿ï¼›è¾¹ç•Œ | cutting edge; boundary | The Pareto frontier shows costâ€“quality trade-offs. |
| trade-off | /ËˆtreÉªdËŒÉ”Ëf/ | æƒè¡¡ | compromise; balance | Compression often trades accuracy for lower cost. |
| budget | /ËˆbÊŒdÊ’Éªt/ | é¢„ç®—ï¼›èµ„æºä¸Šé™ | cap; allowance | Agents can be evaluated under a fixed cost budget. |
| reranker | /ËŒriËËˆrÃ¦Å‹kÉ™r/ | é‡æ’å™¨ | ranker; scorer | A reranker can improve top-k tool selection. |
| knapsack | /ËˆnÃ¦pËŒsÃ¦k/ | èƒŒåŒ…ï¼ˆé—®é¢˜ï¼‰ | packing problem; allocation | Tool calling can be framed as a knapsack problem under budget. |
| reward | /rÉªËˆwÉ”Ërd/ | å¥–åŠ±ï¼ˆå¼ºåŒ–å­¦ä¹ ï¼‰ | payoff; return | Efficiency-aware rewards penalize unnecessary tool calls. |
| penalty | /ËˆpÉ›nÉ™lti/ | æƒ©ç½šé¡¹ | punishment; cost term | A tool-use penalty reduces redundant invocations. |
| distillation | /ËŒdÉªstÉ™ËˆleÉªÊƒÉ™n/ | è’¸é¦ï¼›çŸ¥è¯†æç‚¼ | compression; transfer | Distillation can compress multi-agent coordination into one model. |
| orchestrator | /ËˆÉ”ËrkÉ™ËŒstreÉªtÉ™r/ | ç¼–æ’å™¨ï¼›è°ƒåº¦å™¨ | coordinator; controller | An orchestrator routes subtasks to tools or specialists. |
| retriever | /rÉªËˆtriËvÉ™r/ | æ£€ç´¢å™¨ | fetcher; searcher | External retrievers select tools from large pools. |
| embedding | /ÉªmËˆbÉ›dÉªÅ‹/ | åµŒå…¥è¡¨ç¤º | vector representation; encoding | Embedding similarity supports memory retrieval. |
| similarity | /ËŒsÉªmÉ™ËˆlÃ¦rÉªti/ | ç›¸ä¼¼åº¦ | likeness; affinity | Similarity scores rank memories for retrieval. |
| pruning | /ËˆpruËnÉªÅ‹/ | å‰ªæ | trimming; cutting | Pruning unproductive branches improves search efficiency. |
| sparsification | /ËŒspÉ‘ËrsÉªfÉªËˆkeÉªÊƒÉ™n/ | ç¨€ç–åŒ– | thinning; sparsity | Communication sparsification reduces multi-agent overhead. |
| topology | /tÉ™ËˆpÉ‘ËlÉ™dÊ’i/ | æ‹“æ‰‘ç»“æ„ | structure; layout | Topology design can reduce communication from \(O(N^2)\) to \(O(N)\). |
| consensus | /kÉ™nËˆsÉ›nsÉ™s/ | å…±è¯† | agreement; concord | Consensus protocols may terminate redundant debates early. |
| coordination | /koÊŠËŒÉ”ËrdÉ™ËˆneÉªÊƒÉ™n/ | ååŒï¼›åè°ƒ | cooperation; orchestration | Coordination quality affects both cost and accuracy. |
| kernel | /ËˆkÉËnÉ™l/ | æ ¸ï¼ˆå¦‚è½¬ç§»æ ¸ï¼‰ | core; nucleus | The transition kernel defines environment dynamics in POMDPs. |
| factor | /ËˆfÃ¦ktÉ™r/ | å› å­ï¼›ç³»æ•°ï¼ˆå¦‚æŠ˜æ‰£å› å­ï¼‰ | coefficient; term | The discount factor \(\gamma\) controls long-term rewards. |

#### Verbsï¼ˆåŠ¨è¯ï¼‰

| è‹±æ–‡ | ç¾å¼éŸ³æ ‡ | ä¸­æ–‡å«ä¹‰ | è¿‘ä¹‰è¯ | ç¤ºä¾‹ |
|------|----------|----------|--------|------|
| augment | /É”ËÉ¡ËˆmÉ›nt/ | å¢å¼ºï¼›æ‰©å…… | enhance; enrich | Agents augment a base LLM with memory and tools. |
| compress | /kÉ™mËˆprÉ›s/ | å‹ç¼© | shrink; condense | We compress long histories to bound token usage. |
| retrieve | /rÉªËˆtriËv/ | æ£€ç´¢ï¼›å–å› | fetch; recall | The agent retrieves only the most relevant memories. |
| curate | /kjÊŠËˆreÉªt/ | ç­›é€‰ï¼›ç²¾å¿ƒæ•´ç† | filter; select | Curate memory entries to avoid noise and bloat. |
| externalize | /ÉªkËˆstÉËnÉ™ËŒlaÉªz/ | å¤–ç½®ï¼›å¤–æ˜¾åŒ– | offload; outsource | Externalize knowledge into a retrievable store. |
| invoke | /ÉªnËˆvoÊŠk/ | è°ƒç”¨ï¼ˆå·¥å…·/æ¥å£ï¼‰ | call; trigger | The model decides when to invoke a search tool. |
| allocate | /ËˆÃ¦lÉ™ËŒkeÉªt/ | åˆ†é…ï¼ˆé¢„ç®—/è®¡ç®—ï¼‰ | assign; apportion | Allocate compute adaptively under a token budget. |
| prune | /pruËn/ | å‰ªæï¼›è£å‰ª | trim; cut | Prune expensive branches early in search. |
| distill | /dÉªËˆstÉªl/ | æç‚¼ï¼›è’¸é¦ | extract; condense | Distill successful trajectories into reusable skills. |
| route | /raÊŠt/ | è·¯ç”±ï¼›åˆ†æ´¾ | dispatch; direct | Route subtasks to tools to reduce reasoning tokens. |
| decompose | /ËŒdiËkÉ™mËˆpoÊŠz/ | åˆ†è§£ï¼ˆä»»åŠ¡ï¼‰ | break down; split | Decompose a complex task into smaller subtasks. |
| integrate | /ËˆÉªntÉ™ËŒÉ¡reÉªt/ | é›†æˆï¼›èåˆ | combine; merge | Integrate retrieved snippets into a compact prompt block. |
| optimize | /ËˆÉ‘ËptÉ™ËŒmaÉªz/ | ä¼˜åŒ– | improve; refine | Optimize the costâ€“success trade-off along the trajectory. |
| mitigate | /ËˆmÉªtÌ¬É™ËŒÉ¡eÉªt/ | ç¼“è§£ï¼›å‡è½» | alleviate; reduce | Memory helps mitigate costly retries. |
| amortize | /ËˆÃ¦mÉ™ËŒrtaÉªz/ | æ‘Šé”€ï¼›å‡æ‘Š | spread; distribute | Reusing memory amortizes planning cost over episodes. |
| converge | /kÉ™nËˆvÉËdÊ’/ | æ”¶æ•› | stabilize; settle | Tool policies converge after RL fine-tuning. |
| penalize | /ËˆpiËnÉ™ËŒlaÉªz/ | æƒ©ç½š | punish; dock | Penalize redundant tool calls in the RL objective. |
| evaluate | /ÉªËˆvÃ¦ljuËŒeÉªt/ | è¯„ä¼° | assess; measure | Evaluate success rates under fixed cost budgets. |
| saturate | /ËˆsÃ¦tÊƒÉ™ËŒreÉªt/ | ä½¿é¥±å’Œï¼›å……æ»¡ | overload; fill | Long contexts can saturate the window and degrade accuracy. |
| consolidate | /kÉ™nËˆsÉ‘ËlÉªËŒdeÉªt/ | åˆå¹¶ï¼›å·©å›º | merge; unify | Consolidate memories offline to reduce serving latency. |

#### Adjectivesï¼ˆå½¢å®¹è¯ï¼‰

| è‹±æ–‡ | ç¾å¼éŸ³æ ‡ | ä¸­æ–‡å«ä¹‰ | è¿‘ä¹‰è¯ | ç¤ºä¾‹ |
|------|----------|----------|--------|------|
| efficient | /ÉªËˆfÉªÊƒÉ™nt/ | é«˜æ•ˆçš„ | cost-effective; streamlined | Efficient agents maximize success with minimal resources. |
| agentic | /ËŒeÉªdÊ’É™nËˆtÉªk/ | æ™ºèƒ½ä½“å¼çš„ï¼›ä»£ç†å¼çš„ | autonomous; agent-based | Agentic workflows require planning, tools, and memory. |
| recursive | /rÉªËˆkÉËsÉªv/ | é€’å½’çš„ | iterative; self-referential | The loop is recursive: each step feeds the next. |
| prohibitive | /prÉ™ËˆhÉªbÉ™tÉªv/ | ï¼ˆæˆæœ¬/é—¨æ§›ï¼‰é«˜å¾—éš¾ä»¥æ‰¿å—çš„ | excessive; too costly | Prohibitive latency blocks real-time applications. |
| unbounded | /ÊŒnËˆbaÊŠndÉªd/ | æ— ç•Œçš„ï¼›æ— é™åˆ¶çš„ | limitless; unconstrained | Memory must manage unbounded histories efficiently. |
| hierarchical | /ËŒhaÉªÉ™ËˆrÉ‘ËrkÉªkÉ™l/ | åˆ†å±‚çš„ | multi-level; tiered | Hierarchical memory enables coarse-to-fine retrieval. |
| graph-based | /ËˆÉ¡rÃ¦f beÉªst/ | åŸºäºå›¾çš„ | graph-structured; network-based | Graph-based retrieval supports multi-hop evidence chaining. |
| cost-aware | /ËˆkÉ”Ëst É™ËˆwÉ›r/ | æˆæœ¬æ„ŸçŸ¥çš„ | budget-aware; cost-sensitive | Cost-aware planning trades depth for lower expense. |
| task-agnostic | /tÃ¦sk Ã¦É¡ËˆnÉ‘ËstÉªk/ | ä»»åŠ¡æ— å…³çš„ | generic; non-specific | Task-agnostic rules may drop critical memories. |
| deployment-aware | /dÉªËˆplÉ”ÉªmÉ™nt É™ËˆwÉ›r/ | é¢å‘éƒ¨ç½²çš„ | production-oriented; practical | Deployment-aware designs report end-to-end latency. |
